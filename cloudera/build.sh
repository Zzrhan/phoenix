#!/usr/bin/env bash

# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This is the caller script for the build code. build.sh will build for all products.

# If anything fails, then the build should fail.
set -e

#This is needed for cdh_version.properties
BUILD_TIME=$(date +%Y.%m.%d:%H:%M:%S%Z)
GIT_HASH=$(git rev-parse HEAD)

function big_console_header
{
	local text="$*"
	local spacing=$(( (75+${#text}) /2 ))
	printf "\n\n"
	echo "================================================================="
	echo "================================================================="
	printf "%*s\n"  ${spacing} "${text}"
	echo "================================================================="
	echo "================================================================="
	printf "\n\n"
}

#validate jenkins build parameters
if [ ! -z ${RELEASE_CANDIDATE} ]; then
	if [ "${OFFICIAL}" == "false" ]; then
		big_console_header "Build is marked as a Release candidate but it is not official, failing early."
		exit 2
	fi
fi

# if invoked outside of jenkins, setting workspace to parent
if [ -z "$WORKSPACE" ]; then
	WORKSPACE="$(cd .. && pwd)"
fi
# generating a dummy url, if not running from jenkins
if [ -z "$BUILD_URL" ]; then
	BUILD_URL=http://$(hostname)
fi

# removing previous builds
big_console_header "Removing previous artifacts"

rm -rf build-parcel output-repo gbn_build_*.html cloudera/cdh_version.properties
mvn clean
mvn versions:revert

# Obtain the creds to get s3creds.
wget http://github.mtv.cloudera.com/QE/deploy/raw/master/cdep/data/id_rsa -O /tmp/id_rsa_systest
chmod 600 /tmp/id_rsa_systest

# Retrieve a GBN from the api
export GBN=$(curl http://gbn.infra.cloudera.com/)
if [ -z "$GBN" ]; then
	echo "Could not get GBN for the build"
	exit 1
fi

big_console_header "GBN: $GBN"

export REVNO=${GBN:-0}
export OFFICIAL=${OFFICIAL:false}
export BUILD_TIME=$BUILD_TIME
export GIT_HASH=$GIT_HASH

# getting cdh version from pom.xml
# N.B. this works because we're relying on a released version of CDH
# for the parent (so we can set appropriate versions for CDH components)
# if we switch to developing in concert with a CDH release, we'll
# need to do something like grep the pom to avoid failure when the peer
# cdh directory isn't already on the needed branch.

PARENT_VERSION=$(mvn -q -Dexec.executable='echo' -Dexec.args='${project.parent.version}' --non-recursive exec:exec)

if [ $? -ne 0 -o -z "$PARENT_VERSION" ]; then
	echo "Couldn't get parent project version!"
	exit 1
fi

big_console_header "PARENT_VERSION: ${PARENT_VERSION}"

# getting project version from pom.xml (e.g. 4.14.1-cdh5.16.2-SNAPSHOT)
FULL_VERSION=$(mvn -q -Dexec.executable='echo' -Dexec.args='${project.version}' --non-recursive exec:exec)

if [ -z "$FULL_VERSION" ]; then
	echo "Could not get version from pom.xml"
	exit 1
fi

# getting phoenix version (4.14.1-cdh5.16.2-SNAPSHOT -> 4.14.1)
PHOENIX_VERSION=$(echo $FULL_VERSION | sed -e 's/^\([^-]*\)-.*$/\1/')

if [ -z "$PHOENIX_VERSION" ]; then
	echo "Could not get phoenix version from: $FULL_VERSION"
	exit 1
fi

big_console_header "PHOENIX_VERSION: $PHOENIX_VERSION"

# getting cdh version (4.14.1-cdh5.16.2-SNAPSHOT -> 5.16.2)
CDH_VERSION=$(echo $FULL_VERSION | sed -e 's/^.*cdh\([^-]*\).*$/\1/')

if [ -z "$CDH_VERSION" ]; then
	echo "Could not get cdh version from: $CDH_VERSION"
	exit 1
fi

big_console_header "CDH_VERSION: $CDH_VERSION"

export PARENT_VERSION
export PHOENIX_VERSION
export CDH_VERSION

# getting current branch from git
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)

# generating cdh_version.properties
big_console_header "Generating cdh_version.properties"

cat > cloudera/cdh_version.properties << EOT
# Autogenerated build properties
version=${CDH_VERSION}
git.hash=${GIT_HASH}
cloudera.build-branch=${BRANCH_NAME}
cloudera.pkg.version=phoenix${PHOENIX_VERSION}-cdh${CDH_VERSION}
cloudera.pkg.release=1.phoenix${PHOENIX_VERSION}.p0.${REVNO}
cloudera.pkg.name=phoenix
cloudera.cdh.release=NA
cloudera.build.time=${BUILD_TIME}
EOT

if [ "${OFFICIAL}" == "true" ]; then
	big_console_header "It is an official release, removing -SNAPSHOT"
	mvn versions:set -DremoveSnapshot
fi

# building Phoenix
big_console_header "Building Phoenix"

# phoenix-parcel module uses parcel.patch.count which we use for GBN
mvn install -DskipTests -Dparcel.patch.count=${REVNO}

big_console_header "Creating distro parcels"

OUTPUT_DIR=${WORKSPACE}/phoenix/build-parcel
DIR_PARCEL_TAR=${WORKSPACE}/phoenix/phoenix-parcel/target
SCRIPT_MAKE_MANIFEST=${WORKSPACE}/cdh/lib/python/cauldron/src/cauldron/tools/parcelmanifest.py

rm -rf ${OUTPUT_DIR}
mkdir ${OUTPUT_DIR}

FILE_PARCEL_TAR=$(find ${DIR_PARCEL_TAR} -name '*.parcel.tar' -exec basename {} \;)
PARCEL_BASENAME=$(echo ${FILE_PARCEL_TAR} | sed 's/\.parcel\.tar//')

# append cdh_version.properties to tar file
tar rf ${DIR_PARCEL_TAR}/${FILE_PARCEL_TAR} cloudera/cdh_version.properties \
	--transform "s,^,PHOENIX-${FULL_VERSION}.p0.${REVNO}/lib/phoenix/,"

PARCEL_DISTROS=( "el5" "el6" "el7" "sles11" "sles12" "jessie" "trusty" "wheezy" "xenial")
for distro in "${PARCEL_DISTROS[@]}"
do
	cp ${DIR_PARCEL_TAR}/${FILE_PARCEL_TAR} ${OUTPUT_DIR}/${PARCEL_BASENAME}-${distro}.parcel
done

# generate checksum files
(
	cd ${OUTPUT_DIR}
	for f in ${PARCEL_BASENAME}-*.parcel; do
		sha1sum ${f} > ${f}.sha1
	done
)

# Get the S3 credentials. Needed for pushing final artifacts to the cloud.
ssh -o StrictHostKeyChecking=no -i /tmp/id_rsa_systest s3@cloudcat-s3.infra.cloudera.com build  > ~/.s3-auth-file

# create repos and upload artifacts to s3
DOCKER_IMG="docker-registry.infra.cloudera.com/cauldron/ubuntu1604:latest"
docker pull $DOCKER_IMG
if ! docker inspect $DOCKER_IMG;then
	echo "Docker image not downloaded correctly please check docker image : $DOCKER_IMG"
	exit 1
fi

# This is the post build step. The main idea is to create repos, and upload the artifacts to S3.
# This will need the GBN passed in along with the S3 authorization file.

docker run \
	-v ${WORKSPACE}/phoenix:/phoenix \
	-v ${WORKSPACE}/cdh:/cdh \
	-e GBN="${GBN}" \
	-e PHOENIX_VERSION="${PHOENIX_VERSION}" \
	-e CDH_VERSION="${CDH_VERSION}" \
	-e OFFICIAL="${OFFICIAL}" \
	-e RELEASE_CANDIDATE="${RELEASE_CANDIDATE}" \
	-e BUILD_URL=${BUILD_URL} \
	-e GPG_SIGNING_PASSPHRASE=${GPG_SIGNING_PASSPHRASE} \
	-e GPG_SIGNING_KEY=${GPG_SIGNING_KEY} \
	-e USER=$USER \
	--user=$UID \
	-v ~/.s3-auth-file:/tmp/s3-auth-file \
	--entrypoint /phoenix/cloudera/post_build.sh \
	$DOCKER_IMG

# dump s3 output
URL="http://cloudera-build-us-west-1.vpc.cloudera.com/s3/build/$GBN/"

big_console_header "$URL"

# generating html for jenkins
cat > gbn_build_$GBN.html << EOT
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>$GBN</title>
</head>
<body>
<a href="$URL">$URL</a>
</body>
</html>
EOT
